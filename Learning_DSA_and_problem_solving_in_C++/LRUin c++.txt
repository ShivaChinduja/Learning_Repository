//LRU Implementation 

#include<iostream>
#include<list>
#include<unordered_map>

using namespace std;
class LRU{
    public:
    list<pair<int,int>> cache_list;
    unordered_map<int,list<pair<int,int>>::iterator>cache_map;
    int capacity;
    LRU(int x){
        capacity = x;
    }
    void put(int k , int v){
        auto it = cache_map.find(k);
        if(it!= cache_map.end()){
            it->second->second = v;
            cache_list.splice(cache_list.begin() , cache_list , it->second);
            return;
        }
        if(cache_list.size()== capacity){
            auto it = cache_list.back();
            cache_map.erase(it.first);
            cache_list.pop_back();
        }
        cache_list.push_front({k,v});
        cache_map[k] = cache_list.begin();
        
    }
    int get(int k){
        auto it = cache_map.find(k);
        if(it == cache_map.end()){return -1;}
        cache_list.splice(cache_list.begin() , cache_list, it->second);
        return it->second->second;
        
        
        
    }
};

int main(){
    LRU* obj = new LRU(3);
    obj->put(1 ,10);
    obj->put(2 ,20);
    obj->put(3,40);
    cout << obj->get(2) << endl;;
    obj->put(4,50);
    cout << obj->get(1)<< endl;
    
    
    return 0;
}